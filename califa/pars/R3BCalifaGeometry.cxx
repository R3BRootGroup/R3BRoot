/******************************************************************************
 *   Copyright (C) 2019 GSI Helmholtzzentrum f√ºr Schwerionenforschung GmbH    *
 *   Copyright (C) 2019 Members of R3B Collaboration                          *
 *                                                                            *
 *             This software is distributed under the terms of the            *
 *                 GNU General Public Licence (GPL) version 3,                *
 *                    copied verbatim in the file "LICENSE".                  *
 *                                                                            *
 * In applying this license GSI does not waive the privileges and immunities  *
 * granted to it by virtue of its status as an Intergovernmental Organization *
 * or submit itself to any jurisdiction.                                      *
 ******************************************************************************/

#include <TFile.h>
#include <TGeoManager.h>
#include <TGeoNavigator.h>
#include <TGeoVolume.h>
#include <TMath.h>
#include <TString.h>
#include <TSystem.h>
#include <iostream>
#include <stdlib.h>
#include <vector>

#include <FairLogger.h>

#include "R3BCalifaGeometry.h"

#include <boost/regex.hpp>

R3BCalifaGeometry* R3BCalifaGeometry::Instance(int version)
{
  static thread_local R3BCalifaGeometry* inst{};
  if (inst)
    {
      if (inst->fGeometryVersion == version || version==0)
        return inst;
      else
        {
          throw std::runtime_error("You asked for different geometry versions.");
        }
    }
  else
    {
      if (version == 0)
	{
	  LLOG(fatal) << "called without version, but no existing version. Please call R3BCalifaGeometry::Instance"
	    " once with the correct geometry version (e.g. from your macro) before omitting it.";
	  return nullptr;
	}
      return inst=new R3BCalifaGeometry(version);
    }
}


R3BCalifaGeometry::R3BCalifaGeometry(int version)
    : fGeometryVersion(version)
{

    LOG(info) << "R3BCalifaGeometry::Init()";
    // TODO: if geometries are autogenerated, they belong into the build directory instead!
    TString geoPath = gSystem->Getenv("VMCWORKDIR");
    geoPath += "/geometry/";

    switch (version)
    {
        case 2019:
            // BARREL: demonstrator from 2019
            geoPath += "califa_s444.geo.root";
            fNumChannels = 10000;
            break;

        case 2020:
            // Full BARREL+iPhos version
            geoPath += "califa_2020.geo.root";
            fNumChannels = 4864;
            break;

        case 2021:
            // s455 Experiment: Half Barrel + Full IPHOS
            geoPath += "califa_2021_s455.geo.root";
            fNumChannels = 4864;
            break;
        case 9999:
            // Full Barrel + Full IPHOS
            geoPath += "califa_full.geo.root";
            fNumChannels = 4864;
	    break;
        default:
            LOG(error) << "R3BCalifaGeometry::Unsupported geometry version: " << version;
            return;
    }

    if (gGeoManager && strcmp(gGeoManager->GetTopVolume()->GetName(), "cave") == 0)
    {
        // Already set up (MC mode)
        LLOG(info) << "R3BCalifaGeometry::Using existing geometry";
        // LOG(info) << "R3BCalifaGeometry::Opened geometry file " << geoPath;
        fIsSimulation = kTRUE;
        return;
    }

    // Stand alone mode
    LLOG(info) << "R3BCalifaGeometry::Open geometry file " << geoPath << " for analysis.";
    f = new TFile(geoPath, "READ");
    TGeoVolume* v = dynamic_cast<TGeoVolume*>(f->Get("TOP"));
    if (!v)
    {
        LLOG(error) << "R3BCalifaGeometry::Could not open CALIFA geometry file: No TOP volume";
        return;
    }

    // Is it okay if we just capture TGeoManager? What if every detector does this?
    v->SetName("cave");
    if (!gGeoManager)
        gGeoManager = new TGeoManager();
    gGeoManager->SetTopVolume(v);
    return;
}


const ROOT::Math::XYZVector& R3BCalifaGeometry::GetCrystalCenterPos(Int_t iD)
{
    static std::map<int, ROOT::Math::XYZVector> cache;
    Double_t local[3] = { 0, 0, 0 };
    Double_t master[3];
    const static ROOT::Math::XYZVector invalid(NAN, NAN, NAN);
    const char* nameVolume;
    if (cache.count(iD))
        return cache[iD];

    if (iD > fNumChannels / 2 && iD <= fNumChannels)
      return cache[iD]=GetCrystalCenterPos( iD - fNumChannels / 2);

    if (iD >= 1 && iD <= fNumChannels / 2)
    {
        nameVolume = GetCrystalVolumePath(iD);

        gGeoManager->CdTop();

        if (gGeoManager->CheckPath(nameVolume))
            gGeoManager->cd(nameVolume);
        else
        {
            LOG(error) << "R3BCalifaGeometry: Invalid crystal path: " << nameVolume;
            return cache[iD]=invalid;
        }
        gGeoManager->LocalToMaster(local, master);
    }
    else
    {
        LOG(error) << "R3BCalifaGeometry: Invalid crystalId: " << iD;
        return cache[iD]=invalid;
    }

    return cache[iD] = {master[0], master[1], master[2]};
}

void R3BCalifaGeometry::GetAngles(Int_t iD, Double_t* polar, Double_t* azimuthal, Double_t* rho)
{
    auto& masterV = this->GetCrystalCenterPos(iD);
    *polar = masterV.Theta();
    *azimuthal = masterV.Phi();
    *rho = masterV.r();
    if (std::isnan(*polar) || std::isnan(*azimuthal) || std::isnan(*rho))
        LOG(error) << "R3BCalifaGeometry::GetAngles(" << iD << ",...) returns NaN";
}

const char* R3BCalifaGeometry::GetCrystalVolumePath(Int_t iD)
{
    Int_t alveolusCopy = -1;
    Int_t alvType = -1;
    Int_t cryType = -1;

    // SOLUTION FOR DOUBLE READING CHANNELS
    if (iD > fNumChannels / 2 && iD <= fNumChannels)
        iD = iD - fNumChannels / 2; // for double reading crystals (crystals from 1 to 2432)

    static char nameVolume[400];

    if (iD >= 1 && iD <= fNumChannels / 2)
    {
        if (iD < 33)
        {                          // First ring in BARREL (single crystal per alveolus)
            alvType = 1;           // Alveolus type 1
            alveolusCopy = iD - 1; // copy from 0 to 31
            cryType = 1;           // Only one crystal type (1)
        }
        else if (iD < 2337)
        {                                                                // All 4-crystals alveoli in BARREL and iPhos
            alvType = (Int_t)((iD - 33) / 128) + 2;                      // Alveolus type (2, ..., 19)
            alveolusCopy = (Int_t)((iD - 33 - (alvType - 2) * 128) / 4); // copy from 0 to 31
            cryType = iD - 33 - (alvType - 2) * 128 - alveolusCopy * 4 + 1; // Four crystal types (1,2,3,4)
        }
        else
        {                                                                     // 3-crystals alveoli in iPhos
            alvType = (Int_t)((iD - 2337) / 24) + 20;                         // Alveolus type (20, 21, 22, 23)
            alveolusCopy = (Int_t)((iD - 2337 - (alvType - 20) * 24) / 3);    // copy from 0 to 7
            cryType = iD - 2337 - (alvType - 20) * 24 - alveolusCopy * 3 + 1; // Three crystal types (1,2,3)
        }
        char name_Alv[23][3] = { "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12",
                                 "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23" };
        sprintf(nameVolume,
                "/cave_1/CalifaWorld_0/Alveolus_%s_%i/InnerAlv_%s_0/WrapCry_%s_%i_0/Crystal_%s_%i_0",
                name_Alv[alvType - 1],
                alveolusCopy,
                name_Alv[alvType - 1],
                name_Alv[alvType - 1],
                cryType,
                name_Alv[alvType - 1],
                cryType);
    }
    else
    {
        LOG(error) << "R3BCalifaGeometry: Invalid crystalId: " << iD;
    }

    return nameVolume;
}

double R3BCalifaGeometry::GetDistanceThroughCrystals(ROOT::Math::XYZVector& startVertex,
                                                     ROOT::Math::XYZVector& direction,
                                                     ROOT::Math::XYZVector* hitPos,
                                                     Int_t* numCrystals,
                                                     Int_t* crystalIds)
{
    Int_t maxNumChannels = 0;

    if (numCrystals != NULL && crystalIds != NULL)
    {
        maxNumChannels = *numCrystals;
        *numCrystals = 0;
    }

    TGeoNode* n;

    gGeoManager->InitTrack(startVertex.X(),
                           startVertex.Y(),
                           startVertex.Z(),
                           direction.X() / direction.r(),
                           direction.Y() / direction.r(),
                           direction.Z() / direction.r());

    Double_t distance = 0.;
    const Double_t* pos;
    bool inCrystal = false, wasInCrystal = false;
    TString nodeName;

    // find the distance to the next boundary and then extrapolate the current point/direction
    // with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state
    // after crossing the boundary
    while ((n = gGeoManager->FindNextBoundaryAndStep()))
    {
        nodeName = n->GetName();

        if (inCrystal)
            distance += gGeoManager->GetStep();

        // inCrystal = nodeName.BeginsWith("Crystal_");
        inCrystal = nodeName.BeginsWith("WrapCry_"); // can't enter to Crystal volume

        if (inCrystal && maxNumChannels != 0)
        {
            Int_t cid = GetCrystalId(gGeoManager->GetPath());
            if (cid != -1 && (*numCrystals == 0 || cid != crystalIds[(*numCrystals) - 1]))
            {
                crystalIds[(*numCrystals)++] = cid;
                maxNumChannels--;
            }
        }

        if (hitPos != NULL && inCrystal && !wasInCrystal)
        {
            pos = gGeoManager->GetCurrentPoint();
            hitPos->SetXYZ(pos[0], pos[1], pos[2]);
            wasInCrystal = true;
        }
    }

    return distance;
}

// ROOT (or pyroot) is unable to automatically load dependencies of so's for whatever reason.
// so we try to force loading the lib during var initialisation.
// yes, this is ugly.
// static bool _dummy_load_libboost_regex = []() {
//    char buf[100];
//    snprintf(buf, 100, "%s/lib/libboost_regex.so", getenv("SIMPATH"));
//    return gSystem->Load(buf);
//}();

int R3BCalifaGeometry::GetCrystalId(const char* volumePath)
{ /*
   * Yes, regex matching in the stepping action is probably slow.
   * But if we cared about speed, we would not use string processing here
   * in the first place.
   * At least, this way we have well defined behaviour if something fails,
   * instead of possible out of bounds access consequences (nasal demons etc).
   * Also, it hopefully works with the 2019/s444 geo file too, now.
   */
    static auto restr = "Alveolus_([0-9]+)_([0-9]+).*Crystal_[^_]+_([0-9]+)_";
    static auto re = boost::regex(restr, boost::regex::extended);
    boost::cmatch m;
    if (!boost::regex_search(volumePath, m, re))
    {
        LOG(error) << "R3BCalifaGeometry::GetCrystalId: \"" << volumePath
                   << "\"\n"
                      "does not match RE \""
                   << restr << "\".\n";
        return 0;
    }

    Int_t crystalId;
    Int_t alvType = std::stoi(m[1].str());      // converting to int the alveolus type
    Int_t alveolusCopy = std::stoi(m[2].str()); // converting to int the alveolus copy
    Int_t cryType = std::stoi(m[3].str());      // converting to int the crystal type

    if (cryType < 1 || cryType > 4 || alvType < 1 || alvType > 23)
    { // cryType runs from 1 to 4 while alvType runs from 1 to 23
        LOG(error) << "R3BCalifaGeometry: Wrong crystal numbers (1)";
        LOG(info) << "---- cryType: " << cryType << "   alvType: " << alvType;
        LOG(info) << "path=" << volumePath;
        return 0;
    }

    if (alvType == 1)
        crystalId = 1 + alveolusCopy; // first alveoli ring, one crystal per alveolus
    else if (alvType < 20)
        crystalId = 33 + (alvType - 2) * 128 + alveolusCopy * 4 + (cryType - 1); // four crystal per alveolus
    else
        crystalId = 2337 + (alvType - 20) * 24 + alveolusCopy * 3 + (cryType - 1); // three crystal per alveolus

    if (crystalId < 1 || crystalId > fNumChannels/2)
    { // crystalId runs from 1 to 2432
        LOG(error) << "R3BCalifaGeometry: Wrong crystal numbers (2)";
        LOG(info) << "---- crystalId: " << crystalId;
        return 0;
    }

    return crystalId;
}

ClassImp(R3BCalifaGeometry);
